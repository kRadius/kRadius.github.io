<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="夫博观而约取，厚积而薄发">
<meta property="og:type" content="website">
<meta property="og:title" content="Something What I Can Do">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Something What I Can Do">
<meta property="og:description" content="夫博观而约取，厚积而薄发">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Something What I Can Do">
<meta name="twitter:description" content="夫博观而约取，厚积而薄发">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Something What I Can Do </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Something What I Can Do</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS | github | hexo</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      


      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/04/消息机制和Category小记/" itemprop="url">
                  被忽视的iOS架构模式-MVP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-04T20:42:30+08:00" content="2016-10-04">
              2016-10-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">设计杂谈</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习OC到一定阶段的时候，大部分都会接触到OC的底层机制。然后就会碰到Runtime、RunLoop这些名词。我自己在学习的过程中，第一次是通过一个“神奇的视频”开始，随后一段时间，就看到了不计其数的博客开始记录自己的Runtime学习之旅。我以前一直觉得，别人写过了的东西其实都没有必要再写了。不过最近反思，这些东西更多的时候是自己学习过程的记录，因为了解了知识点之后，并不一定能完整的诉诸文字或者使人昭昭。<code>I see and I forget, I hear and I remember, I do and I understand！</code></p>
<h4 id="u6D88_u606F_u673A_u5236"><a href="#u6D88_u606F_u673A_u5236" class="headerlink" title="消息机制"></a>消息机制</h4><p>消息发送机制是runtime的重要组成部分。明白了一个消息的完整发送过程，对oc对象的本质以及runtime肯定会有一个宏观的了解。</p>
<p>首先是“对象”，OC的对象其实就是一个含有isa指针的结构体。包括<code>实例对象(instance)</code>，<code>类对象(class)</code>，<code>元类对象(meta class)</code>。实例对象包含实例变量、类对象包含实例方法（’ - ‘号），元类对象包含类方法。当然，这些对象中不仅仅包含这些东西。但是对于理解消息机制，知道这些大概的差不多了，以下是简单的图解。<br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/runtime_classes.png" alt="class"></p>
<p>所以在对一个对象发消息的时候，如果是向实例对象发送消息，则是在他的类对象中找([aFoo bar])；向类对象发送消息则是在元类中找([Foo bar])。</p>
<p>寻找方法是怎样的过程，则需要看一下objc_msgSend的源码<br>（<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">源码下载地址</a>）</p>
<p>下载一个比较新的（我下的是objc4-680），在工程中全局搜索<code>objc_msgSend(</code>，你会发现有有不同版本的objc_msgSend，而且全都是汇编。很显然这肯定是不同CPU下的优化，不过大概的流程都是一样的。objc_msgSend的方法原型是<code>id objc_msgSend(id self, SEL _cmd, ...)</code>。消息发送的流程，简单的一句话概括：方法的接收者在isa指向的对象的‘方法列表’中搜寻SEL对应的IMP，在父类不为nil的情况下继续沿着继承体系向上找。如果最终仍然找不到则会走消息转发流程。</p>
<p>像这种几乎每秒要调用上万次的方法，肯定会极度优化。缓存是必要的，不然每次走上面一通流程没法儿玩。还有像《52个方法》中说的“<a href="https://zh.wikipedia.org/wiki/尾调用" target="_blank" rel="external">尾调用优化</a>“。以下是objc-msg-i386s中的方法（x86_64的和这个不一样，思路肯定是一样的）<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> id objc_msgSend(id self, SEL	_cmd,...);</span><br><span class="line"> <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">	ENTRY	_objc_msgSend</span><br><span class="line">	MESSENGER_START</span><br><span class="line">	CALL_MCOUNTER</span><br><span class="line"></span><br><span class="line">// load receiver and selector</span><br><span class="line">	movl    selector(%esp), %ecx</span><br><span class="line">	movl	self(%esp), %eax</span><br><span class="line"></span><br><span class="line">// check whether selector is ignored</span><br><span class="line">	cmpl    $ kIgnore, %ecx</span><br><span class="line">	je      LMsgSendDone		// return self from %eax</span><br><span class="line"></span><br><span class="line">// check whether receiver is nil </span><br><span class="line">	testl	%eax, %eax</span><br><span class="line">	je	LMsgSendNilSelf</span><br><span class="line"></span><br><span class="line">// receiver (in %eax) is non-nil: search the cache</span><br><span class="line">LMsgSendReceiverOk:</span><br><span class="line">	movl	isa(%eax), %edx		// class = self-&gt;isa</span><br><span class="line">	CacheLookup WORD_RETURN, MSG_SEND, LMsgSendCacheMiss</span><br><span class="line">	xor	%edx, %edx		// set nonstret for msgForward_internal</span><br><span class="line">	MESSENGER_END_FAST</span><br><span class="line">	jmp	<span class="keyword">*</span>%eax</span><br><span class="line"></span><br><span class="line">// cache miss: go search the method lists</span><br><span class="line">LMsgSendCacheMiss:</span><br><span class="line">	MethodTableLookup WORD_RETURN, MSG_SEND</span><br><span class="line">	xor	%edx, %edx		// set nonstret for msgForward_internal</span><br><span class="line">	jmp	<span class="keyword">*</span>%eax			// goto <span class="keyword">*</span>imp</span><br><span class="line"></span><br><span class="line">// message sent to nil: redirect to nil receiver, if any</span><br><span class="line">LMsgSendNilSelf:</span><br><span class="line">	// %eax is already zero</span><br><span class="line">	movl	$0,%edx</span><br><span class="line">	xorps	%xmm0, %xmm0</span><br><span class="line">LMsgSendDone:</span><br><span class="line">	MESSENGER_END_NIL</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">// guaranteed non-nil entry point (disabled for now)</span><br><span class="line">// .globl _objc_msgSendNonNil</span><br><span class="line">// _objc_msgSendNonNil:</span><br><span class="line">// 	movl	self(%esp), %eax</span><br><span class="line">// 	jmp     LMsgSendReceiverOk</span><br><span class="line"></span><br><span class="line">LMsgSendExit:</span><br><span class="line">	END_ENTRY	_objc_msgSend</span><br></pre></td></tr></table></figure></p>
<p>汇编代码不理解没关系，就看注释就知道大概是干嘛的，但是需要注意一下他的方法调用顺序，不然很容易迷失在源码里:D。主要就是两件事情查找缓存和查找MethodList，之前还有关于nil的处理。刨根稳定的事情，已经有人做的很好了，推荐看这个</p>
<p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="external">Objective-C 消息发送与转发机制原理</a></p>
<p>有些地方看不懂，明白大概流程就行了:D。如果在继承体系中都没找到，剩下的就是消息转发的流程。消息主要转发分俩流程</p>
<ol>
<li>问你能不能动态的给这个selector添加一方法？或者你给我一个别的target区响应这个操作也好啊（可以这样实现组合模式）（这个步骤也称为“快速消息转发”）</li>
<li>如果你做不到1，那么就只能交给someoneelse来处理了（标准消息转发）</li>
</ol>
<p>这些在objc-class.mm中能都看到完整的处理过程</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> _class_resolveMethod</span><br><span class="line"><span class="keyword">*</span> Call +resolveClassMethod or +resolveInstanceMethod.</span><br><span class="line"><span class="keyword">*</span> Returns nothing; any result would be potentially out-of-date already.</span><br><span class="line"><span class="keyword">*</span> Does not check if the method already exists.</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        // try [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        // and [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO/<span class="keyword">*</span>initialize<span class="keyword">*</span>/, YES/<span class="keyword">*</span>cache<span class="keyword">*</span>/, NO/<span class="keyword">*</span>resolver<span class="keyword">*</span>/)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿区分了是类对象还是元类对象，分别对应实例方法和类方法的resolution(解析)。源码里的注释指出了这会调用我们实际开发中的哪个方法。如果是Meta-Class，在没有找到IMP的情况下，依然去尝试实例方法，这可能是为了确保你有没有正确添加IMP。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> lookUpImpOrNil.</span><br><span class="line"><span class="keyword">*</span> Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, id inst, </span><br><span class="line">                   bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    if (imp == _objc_msgForward_impcache) return nil;</span><br><span class="line">    else return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看<code>IMP lookUpImpOrNil(Class cls, SEL sel, id inst, 
                   bool initialize, bool cache, bool resolver)</code>的时候，记得把参数带进去看，因为这就是<code>_class_resolveMethod</code>消息转发第一步的一个逻辑处理，不然容易在<code>lookUpImpOrForward</code>绕半天。<code>lookUpImpOrForward</code>是一个标准的查找IMP的过程，里面带有了各种各样的检查，查找缓存、判断class是不是被释放了、在父类里找一通…，而lookUpImpOrNil,没找到ruturn nil，并把imp设为<code>_objc_msgForward_impcache</code>缓存起来（对应传进来的SEL）。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	//摘自lookUpImpOrForward方法</span><br><span class="line">    // <span class="type">No</span> implementation found, <span class="keyword">and</span> <span class="keyword">method</span> resolver didn't help. </span><br><span class="line">    // <span class="type">Use</span> forwarding.</span><br><span class="line"></span><br><span class="line">    _cache_addForwardEntry(cls, sel);</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> _cache_addForwardEntry(<span class="type">Class</span> cls, <span class="type">SEL</span> sel)</span><br><span class="line">&#123;</span><br><span class="line">    cache_entry *smt;</span><br><span class="line">  </span><br><span class="line">    smt = (cache_entry *)malloc(sizeof(cache_entry));</span><br><span class="line">    smt-&gt;name = sel;</span><br><span class="line">	//把这个imp设为缓存</span><br><span class="line">    smt-&gt;imp = _objc_msgForward_impcache;</span><br><span class="line">    <span class="keyword">if</span> (! _cache_fill(cls, (<span class="type">Method</span>)smt, sel)) &#123;  // fixme hack</span><br><span class="line">        // <span class="type">Entry</span> <span class="keyword">not</span> added to cache. <span class="type">Don</span>'t leak the <span class="keyword">method</span> struct.</span><br><span class="line">        free(smt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<br><code>void _class_resolveInstanceMethod</code>方法里，就会找到这个缓存的方法，并重新调用一次objc_msgSend,然后出发消息转发流程。</p>
<p>也就是在这一步添加的方法，会被缓存起来，下次发送这个SEl的时候都不会触发这个转发步骤了，直接在缓存中就找到了对应的实现。所以在这一步处理消息转发的最好的。<br>最终触发的方法是 <code>id _objc_msgForward(id self, SEL _cmd,...)</code>。接下来就是完整的消息转发流程。 这个方法的源码是汇编写的，全局搜索<code>_objc_msgForward(</code>则可以找到。</p>
<p>之后就是给你一次机会转发给另外一个对象，不过以这样的方式处理，方法名，参数信息啥的都不能改变，和resolve方式的效果是一样的，而且还不如之前的处理方式（前一步有缓存）。如果这步返回nil，那么接下来就是我们常见的<code>方法签名+invocation调用</code>的完整转发方式。</p>
<p>####为什么Category中不能添加属性</p>
<p>其实这个问题是Category的加载问题。在美团的“<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a>“中对Category进行了毫分缕析，讲的非常明白，看完之后必定会受益良多。对上述问题也有提及</p>
<blockquote>
<p>但是category则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而Category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
</blockquote>
<p>从文章里的源码分析来看，runtime是在运行期间去加载Category里添加的方法。小提一下，在Category添加如下代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)foo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>他只会生成name的setter/getter方法的声明，并没有他俩的实现，更不会像在@interface 或者 extension里边那样去自动生成_name实例变量。并且，编译器也没有警告⚠️。因为他认为你会在运行时添加他们的实现，或者在被外部引用的时候会实现方法。</p>
<p>在<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime#//apple_ref/c/func/class_addMethod" target="_blank" rel="external">官方的文档</a>中,向类添加成员变量的方法是<code>class_addIvar</code>。这个方法只能在<code>objc_allocateClassPair</code><br>和<code>objc_registerClassPair</code>之间调用。也就是只能在类的构造期间去添加。而</p>
<blockquote>
<p>This function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.</p>
</blockquote>
<p>向一个已经存在的基类添加成员变量，会导致已经构造出来的实例无法使用。第一个问题里已经指出，”成员变量是被包含在类实例里的”。换句话说，如果你修改了基类的结构，那么构建出来的实例就不符合类的定义了。而方法是存在objc_class里的。添加方法并不会影响类的结构布局。</p>
<p>用objc_associateObject关联的对象，是在一个全局的Hash表里边存储的，并不是直接添加到类的结构里。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/25/一些关于ChildViewController的问题/" itemprop="url">
                  关于ChildViewController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-25T15:13:54+08:00" content="2016-05-25">
              2016-05-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/UIKit/" itemprop="url" rel="index">
                    <span itemprop="name">UIKit</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>偶然间看到了几个问题，都是关于 childViewController,发现有一些点自己理解的可能不够到位，对一些概念也是模糊不清，而且childViewController在实际的开发工作中，是一个解耦的利器，所以值得对 childViewController 研究一下。</p>
<p>文章围绕四个问题：</p>
<ol>
<li>What is ChildViewController？</li>
<li>ChildViewController 的加载时机</li>
<li>viewDidLoad, viewWillAppear, viewWillDisappear等这些方法在 childViewController 的调用时机</li>
<li>memeryWarning 时 childViewController 会如何？parentViewController 是否会释放一些childViewController?</li>
</ol>
<h3 id="1-What_is_ChildViewController_3F"><a href="#1-What_is_ChildViewController_3F" class="headerlink" title="1.What is ChildViewController?"></a>1.What is ChildViewController?</h3><p>先理解一个宏观上的概念 —— Container ViewController。</p>
<blockquote>
<p>Container view controllers are a way to combine the content from multiple view controllers into a single user interface. Container view controllers are most often used to facilitate navigation and to create new user interface types based on existing content. Examples of container view controllers in UIKit include <code>UINavigationController</code>, <code>UITabBarController</code>, and <code>UISplitViewController</code>, all of which facilitate navigation between different parts of your user interface. —— <strong>View Controller Programming Guide for iOS</strong></p>
</blockquote>
<p>由此可知，Container ViewController 其实是一个管理其他ViewController的视图的一个Controller。文档中指出，UIKit 中UITabBarController 等这些Controller，其实都可以称作Container ViewController。 比如 UITabbarController, 通过比对 viewControllers 属性 和 childViewControllers 属性可知，其实这二者是一样的。在呈现上最为直观的应该是Pad开发中专用的UISplitViewController</p>
<p>图 1-1：UISplitViewController</p>
<p><img src="http://7xpoeq.com1.z0.glb.clouddn.com/VCPG-split-view-inerface_5-2_2x.png" alt="UISplitViewController"></p>
<p>根据这些概念，其实 childViewController 就是被管理的控制器（解释起来略显中二）。 要构建一个自己的Container ViewController，关键是要理解 Container 和 Contained ViewController 之间的关系。了解了二者的关系，才能帮助你理解他们二者的内容该如何显示，Container是内在是如何管理 Children 的。</p>
<p>在StoryBoard中，拖一个 ‘ContainerView’ 就可以直接构建起这样的’Parent-Child‘关系了。像这样：</p>
<p>图 1-2：StoryBoard 中添加 ContainerView</p>
<p><img src="http://7xpoeq.com1.z0.glb.clouddn.com/StoryBoard-Container.png" alt="Alt text"></p>
<p>左图中的Container部分，相当于是一个呈现右边 childViewController 内容的 placeholder 对象。当你打算把这个 ‘placeholder’ 作为 IBOutlet 拖到对应的控制器里边时候，会发现，他是一个 UIView对象，然后你就可以对他加上相应的 size 或者 constraint 来适应屏幕大小（这是不是也是一种适配的方式呢？）。需要注意的一点。这个 placeholder 呈现的是 childViewController 的 <code>rootView</code> ，也就是 vc.view 这个属性。</p>
<p>而如果你是通过代码的方式去创建这样的 parent-child 关系，你需要以下4个步骤：</p>
<ol>
<li>调用 Parent 的 addChildViewController: 方法</li>
<li>把 Child 的 rootView 加到 Parant 的 视图层级上，不一定是 rootView</li>
<li>设置 Child 的 frame。可以添加约束，但是要先 addSubview:</li>
<li>调用 Child 的 didMoveToParentViewController: 方法</li>
</ol>
<p>Listing 1-1: 添加一个 childViewController 到 Container 上</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ViewControllerB *childVc = [[ViewControllerB alloc] init]<span class="comment">;</span></span><br><span class="line">[self addChildViewController:childVc]<span class="comment">;</span></span><br><span class="line">childVc.view.frame = CGRectMake(0, 0, 100, 100)<span class="comment">;</span></span><br><span class="line">[self.view addSubview:childVc.view]<span class="comment">;</span></span><br><span class="line">[childVc didMoveToParentViewController:self]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>addChildViewController: 只会调用 childViewController 的 willMoveToParentViewController: ，文档中如是说（参考List 1-1）：</p>
<blockquote>
<p>In the preceding example, notice that you call only the didMoveToParentViewController: method of the child. That is because the addChildViewController: method calls the child’s willMoveToParentViewController: method for you. The reason that you must call the didMoveToParentViewController: method yourself is that the method cannot be called until after you embed the child’s view into your container’s view hierarchy.</p>
</blockquote>
<p>didMoveToParentViewController: 这个方法，是为了告知 childViewController<br>它现在有一个 parent view controller。你可以在你的 child 中重载这个方法，如果他需要知道这个 notice 的话。不过文档中指出</p>
<blockquote>
<p>If you are implementing your own container view controller, it must call the didMoveToParentViewController: method of the child view controller after the transition to the new controller is complete or, if there is no transition, immediately after calling the addChildViewController: method.</p>
</blockquote>
<p>也就是你一定要调用这个方法啊！不过说实在的，我找了半天也没有找到为什么一定要调用这两个方法。猜测也就是可能会传递一些系统的事件给 childViewController 。后来我发现了 stackOverFlow 上 <a href="http://stackoverflow.com/questions/17192005/what-does-addchildviewcontroller-actually-do" target="_blank" rel="external">What does addChildViewController actually do?</a> 关于这个问题的讨论，才更加了解，这系列方法的作用。</p>
<h3 id="2-ChildViewController__u7684_u52A0_u8F7D_u65F6_u673A"><a href="#2-ChildViewController__u7684_u52A0_u8F7D_u65F6_u673A" class="headerlink" title="2.ChildViewController 的加载时机"></a>2.ChildViewController 的加载时机</h3><p>这个问题其实有点模棱两可。</p>
<p>这是在 InterfaceBuild 中的情况。</p>
<blockquote>
<p>When you load a view controller with one or more container views, Interface Builder also loads the child view controllers associated with those views. The children must be instantiated at the same time as the parent so that the appropriate parent-child relationships can be created.</p>
</blockquote>
<p>如果是以 Programmatically 方式，那么是在把 child 加载到 Parent 的视图层级关系时候(<code>[parent addSubView:child.view]</code>)，才开始走 childViewController 的生命周期方法。</p>
<h3 id="3-viewDidLoad_2C_viewWillAppear_2C_viewWillDisappear_u7B49_u8FD9_u4E9B_u65B9_u6CD5_u5728_childViewController__u7684_u8C03_u7528_u65F6_u673A"><a href="#3-viewDidLoad_2C_viewWillAppear_2C_viewWillDisappear_u7B49_u8FD9_u4E9B_u65B9_u6CD5_u5728_childViewController__u7684_u8C03_u7528_u65F6_u673A" class="headerlink" title="3.viewDidLoad, viewWillAppear, viewWillDisappear等这些方法在 childViewController 的调用时机"></a>3.viewDidLoad, viewWillAppear, viewWillDisappear等这些方法在 childViewController 的调用时机</h3><p>这个问题和上面那个其实有重叠的部分。还是要分 InterfaceBuild 和 Programmatically 俩种方式。</p>
<p>如果是在 InterfaceBuild 中，按照问题2引入的文档描述，parent 和 child 是同时加载的。二者的生命周期方法调用顺序如下(ViewControllerB 为 child)：</p>
<p>图:1-3 StoryBoard中Parent-Child生命周期<br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/IB-LifeCycle.png" alt="Alt text"></p>
<p>如果是以 Programmatically 方式在 Parent 的 viewDidLoad: 中添加 childViewController 的话，结果如下：</p>
<p>图:1-3 Programmatically中Parent-Child生命周期<br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/Program-LifeCycle.png" alt="Alt text"></p>
<p>通过二者的比较，发现 Parent 和 Child 其实都是同一时候收到 System Event 的。而且，基本上都是 Parent 的方法先被调用。文档中有这样一句话：</p>
<blockquote>
<p>The parent-child relationship ensures that the children receive any relevant system messages.</p>
</blockquote>
<p>有点需要注意，上面已经提到，Child 是在被 add 到 Parent 的视图层级关系时候才开始 LifeCycle 方法的。并不是在 didMoveToParentViewController: 时。</p>
<h3 id="4-Memory_Warning"><a href="#4-Memory_Warning" class="headerlink" title="4.Memory Warning"></a>4.Memory Warning</h3><p>首先我们得知道，ViewController 自身在收到 Memory Warning 的时候是怎么处理的。 原则上，如果当前视图已经加载到了内存中，并且没有显示在 window 上，那么可以将其内部的的一些资源释放。在 iOS 6 以下，ViewController 在收到内存警告的时候，默认会执行 <code>self.view = nil</code>操作的。而 iOS 6+ 即使没有显示在 window 上，系统也不会默认释放 view。</p>
<p>我们回到这个问题上：<strong>‘memeryWarning 时 childViewController 会如何？parentViewController 是否会释放一些childViewController’?</strong> 在 parent-child 的关系体系中（就是已经以正确的构建），childViewController 是可以收到内存警告的。如果仅仅是把 child.view 加到了 parent 的 view hierarchy 中，肯定是收不到。</p>
<p>那 parent 是否会 释放自己的 childViewController？经过测试（iOS 9），发现并不会。</p>
<p>当然，如果需要的话，你也可以在 childViewController 里面去做一些释放资源的工作，原则还是如上所说。</p>
<p>小结一下，研究这个问题虽然有点累人，不过还是玩的开心。:D</p>
<p>参考资源：<br><a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html#//apple_ref/doc/uid/TP40007457-CH11-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html#//apple_ref/doc/uid/TP40007457-CH11-SW1</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/04/被忽视的iOS架构模式-MVP/" itemprop="url">
                  被忽视的iOS架构模式-MVP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-04T21:35:50+08:00" content="2016-02-04">
              2016-02-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">设计杂谈</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前一段时间，业界关于iOS架构模式的讨论可谓是如火如荼。从讨伐人人得而诛之的MVC开始，MVCS、MVVM、MVP等设计的思想，普天盖地的出现在iOSer的视野中。由于RAC的出现，MVVM这个被大家讨论的最多的词汇，更是如日中天。从基础的MVVM教程开始（iOS 程序猿的，英文好的朋友可以看看Ray上的Toturial），乃至到批判的文章（唐巧的《被神话的MVVM》），一应俱全。但是关于其他的MVP此类的，大家都是用来做为比较的例子，一笔带过。在我的阅读的范围之内，好像没有见过有谁去详细的解释了一下，至少侧重点不在于此。鉴于此，发表一下个人对于MVP的看法，并且附上相应的Demo。</p>
<p>我们知道，上述所有的设计模式的目的，都是为了解放负担过重的Controller。超过了500行的Controller，基本上就要靠搜索来定位代码了，于己于人，都非常不友好。<br>MVP，不是Most Valuable Player，是从MVC思想中，淡化了Controller的概念，把Controller的大部分业务逻辑，转交到Presenter中，弱化了Controller和Model、View之间的强依赖关系。Presenter可以剥离Controller中<code>View的事件处理</code>，同时也可以<code>负责与Model</code>的交互，Controller自身的一些比如Controller之间的跳转，还是自身负责。这儿的Model，我们可以理解成一个Manager，一个操作数据层（网络or本地），不仅仅是一个继承自NSObject的对象。相比于MVVM，缺少了双向绑定的机制，好处是不会有那么高的耦合，提高了自身的可扩展性和灵活性。</p>
<p><strong>MVP简意</strong><br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/MVP%E7%AE%80%E6%84%8F.jpg" alt="MVP简意"></p>
<p>其中还有好多的数据回调、传递。</p>
<p>我看完很多文章之后仅仅有了一个概念，“哦，原来是这么回事”，然后想写一个Demo实践一下，感觉又远远不止如此。不知道有多人是和我这样。所以，我参照各方资料写了一个我理解的中的<a href="https://github.com/kRadius/MVPDemo" target="_blank" rel="external">示例</a>。实现从网络获取json数据，然后点击进入详细界面这么一个需求。</p>
<p><strong>ListViewController 的结构</strong><br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/MVP_1_1.jpg" alt="ListViewController的结构"></p>
<p>可以看到，VC直接持有了Presenter和DataManager（放下手中的西瓜刀，这DataManager其实是给Presneter用的）。还有一个DataSource是用来分离TableView的代理方法，这个给ViewContrller减负的技巧，objc.io开篇就讲了，有兴趣的可以回去翻阅。UIActivityIndicatorView就是象征VC可能持有的一系列变量（诸如刷洗按钮等）。ListViewProtocol是把ViewController里边的一些处理定义成协议，交给Presenter。做这些所有的目的，都是为了给VC瘦身，合理的减负。</p>
<p><code>ListViewProtocol</code>中，把VC中可以或者需要分离的逻辑，定义成协议。<br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/MVP_2.jpg" alt="ListViewProtocol"><br>之前我们看到，其实是ListViewController实现了这个协议，只不过这些协议方法的调用地方是在Presenter里。比如说，在请求开始之前，-(void)startLoading。获取到了数据之后，就调用-(void)receivedListData:(NSArray *)array，然后刷新tableView之类的事情就可以做了。因为有些事情还是适合在VC里边自个儿做。</p>
<p>DataManager在这需求里边就需要有一个获取数据的方法，用的是block回调。<br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/MVP_4.jpg" alt="DataManager"><br>另外那个DataArray可以让VC去持有。</p>
<p>最关键的<code>Presenter</code><br><img src="http://7xpoeq.com1.z0.glb.clouddn.com/MVP_3.jpg" alt="Presenter实现"><br>在MVP里边，P就是核心的调度者。干的就是以前VC的活。前面提到，DataManager其实是最主要是给Presenter用的。Prensenter需要有个可以初始化这俩变量的地方，并且发起数据请求。Demo就是在config这个方法里做的。有一点需要注意的是，他们之间的<code>循环引用问题</code>，该用weak的地方就用weak。这里解释一下为什么定义那么多协议。我觉得协议里的方法可以理解成需求，然后甭管你是谁，只要能够实现这些需求，就能够成为Presenter，成为Manager。这样不知道算不算是一种解耦的方式。</p>
<p>Demo里的核心部分就是这些了，详情页面的和这个差不多，看到了工程里边的东西，一下就会明白的。</p>
<p>总的来说，MVP提供了良好的灵活性和扩展性，对于写单元测试的来说，也是较为可控。不过，于我们所见，代码量多了不少，另外也没有那View和Model的绑定机制。还是那句话，没有最好的设计模式，合适自己需求的才是最好的。</p>
<p>PS：Demo里的数据来自豆瓣，偶尔会有福利。玩的开心 :D</p>
<p>请尊重原创,保持原链接 :D</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/30/something-about-hexo/" itemprop="url">
                  搭建hexo躺过的坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-30T17:56:29+08:00" content="2015-12-30">
              2015-12-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index">
                    <span itemprop="name">hexo</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>辛苦的整了一个下午，终于搭建了一个自己的小窝，还是比较开心的。如果你能看到这个文章，那么你肯定知道为什么自己要去做搭建博客这样一件事（这逻辑稍显诡异）。我相信每一个有点追求的程序员都会去写点东西（并没有鄙视超凡脱俗又不喜欢写东西的大神的意思），一方面回馈社区，另一方面也可以提高自己的能力。</p>
<p>搭建hexo的过程中，一般都不会一帆风顺，这也正常，这就和我们写代码会遇到bug一样，搭个这玩意儿，就依葫芦画瓢，按部就班就行，说来确实没什么大不了的。不过我猜，很多人hexo的第一篇博客都是记录自己躺过的坑: ]（前人勤栽树，后人好乘凉）。<br>    之前那些从安装node到注册github这些的，前辈们已经讲的很清楚了。不再重复以凑篇幅，在这提供一些链接吧。</p>
<h6 id="u94FE_u63A5"><a href="#u94FE_u63A5" class="headerlink" title="链接"></a>链接</h6><ul>
<li>金石开 <a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="external">http://www.cnblogs.com/zhcncn/p/4097881.html</a></li>
<li>潘柏信 <a href="/leopardpan.github.io">leopardpan.github.io</a></li>
<li>wsgzao <a href="http://wsgzao.github.io/post/hexo-guide/#前言" target="_blank" rel="external">http://wsgzao.github.io/post/hexo-guide/</a></li>
</ul>
<p>按照他们的来，差不多能搭起来，而且里面也记录了一些坑，如果自己遇到了，可以比照比照。</p>
<p>我遇到的就是一个坑就是少这少那儿的插件，这个潘的博客里边已经写的比较清楚了。</p>
<p>第二个坑，确实坑！配置文件的时候一定要注意”<strong>YAML YAML YAML</strong>“（Yet Another Markup Language）语法。我按照潘的写法更改type之类配置的时候，一不小心在冒号之后没有加空格。然后hexo deploy的时候没有啥反应，本着<code>&quot;Unix没有消息就是最好的消息&quot;</code>的原则，我还以为这样就部署成功了。然后上自己的github一看，蒙了。然后各种各样的折腾，甚至我把public文件夹下的东西自己给上传到了git（这样还真可以显示），花了比前面那些工作还多的时间，最后发现是少了一空格- -！（这种感觉相信你也体会过: ]）。部署成功的样子应该是这样的</p>
<p><img src="http://7xpoeq.com1.z0.glb.clouddn.com/1.pic_hd.jpg" alt="Alt text"></p>
<p>而不是啥都没显示 - - !。</p>
<p>最后，既然你要写东西，MarkDown还是要会一点的。这个其实都很简单，记住一些常用的就行了。你以前没用过是吗？好，收好这个链接 <a href="http://wowubuntu.com/markdown/。" target="_blank" rel="external">http://wowubuntu.com/markdown/。</a></p>
<p>这么多？嫌麻烦？那就用这个吧 <a href="https://maxiang.io/" target="_blank" rel="external">https://maxiang.io/</a> 。那我上哪儿去写啊？Sublime 啥的随便你自己挑。不过同事推荐的这个叫马克飞象的，Evernote出品，个人觉得很nice啊！喜欢的可以尝试一下。给出下载链接吧，谁叫我是雷锋呢？</p>
<ul>
<li><a href="http://maxiang.info/client_zh" target="_blank" rel="external">马克飞象</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xpoeq.com1.z0.glb.clouddn.com/psb.jpeg"
               alt="Radius" />
          <p class="site-author-name" itemprop="name">Radius</p>
          <p class="site-description motion-element" itemprop="description">夫博观而约取，厚积而薄发</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Radius</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  
  


</body>
</html>
